*原题链接：👉：[最佳买卖股票时机含冷冻期](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/)*

题目描述:

1. 给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。​

2. 设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

3. 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。

思路：

> 动态规划，知道是动态规划，但是不知道怎么动态规划😥
> 一开始自己列的状态是三种，`in`、`freeze`、`out`三个状态，但是没能想的怎么转移😭

- 题解：

将每一天作为一个数组，数组内三个值，`0,1,2`分别意味着:

    - 0： 持有股票
    - 1：不持有股票，卖出，是冷冻期
    - 2： 不持有股票，不是冷冻期
对应的转移方程即有三种。

    - 0的情况下：持有股票，可以分为两种情况
        - ①、前一天也持有的
        - ②、今天买入的
        - Math.max(dp[i-1][0], dp[i-1][2] - prices[i])
    - 1的情况下：卖出股票，那么就获得利益
        - dp[i-1][0]+prices[i]
    - 2的情况下：冷冻期呢，也有两种情况
        - ①、前一天卖出获得的收益，或者前一天不操作继承的收益
        - Math.max(dp[i-1][1], dp[i-1][2])

*其实感觉官方结束划分的是冷冻期，非冷冻期的三个状态，有点不如，卖，买，冻结（不操作），这样子划分好*

**code**
```
var maxProfit = function(prices) {
    // f[i][0]: 手上持有股票的最大收益
    // f[i][1]: 手上不持有股票，并且处于冷冻期中的累计最大收益
    // f[i][2]: 手上不持有股票，并且不在冷冻期中的累计最大收益
    let dp = new Array(prices.length).fill(0).map(_=>new Array(3).fill(0))
    dp[0] = [-prices[0], 0, 0];
    for(let i = 1; i < prices.length; i++) {
        // 第i天计划买入，因此就是前一天非冷冻情况下减去今天价格
        dp[i][0] = Math.max(dp[i-1][0], dp[i-1][2]-prices[i]);
        // 冷冻期前卖出，前一天持有的情况下加今天卖出价格
        dp[i][1] = dp[i-1][0]+prices[i];
        // 冷冻期这一天的收益，要么继承前一天卖出的价格，要么继承前一天冷冻的价格
        dp[i][2] = Math.max(dp[i-1][1], dp[i-1][2]);
    }
    return Math.max(dp[prices.length - 1][1], dp[prices.length -  1][2]);
};
```