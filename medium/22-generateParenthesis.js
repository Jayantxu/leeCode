/**
 * @param {number} n
 * @return {string[]}
 */
 // 数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。

// 输入：n = 3
// 输出：[
//        "	( ( ( ) ) ) ",
//        " ( ( ) ( ) ) ",
//        " ( ( ) ) ( ) ",
//        " ( ) ( ( ) ) ",
//        " ( ) ( ) ( ) "
//      ]

// 感觉像动态规划？
// (  )

var generateParenthesis = function(n) {
	let helper = (left, right, n, s, ans) => {
		// termination
	    if (left == n && right == n) {
	        return ans.push(s);
	    }
	    if (left < n) helper(left + 1, right, n, s + '(', ans);
	    if (right < left) helper(left, right + 1, n, s + ')', ans);
	}
	let ans = [];
    helper(0, 0, n, '', ans);
    return ans;
};
console.log(generateParenthesis(2));
console.log(generateParenthesis(3));

/*

s = ''   n = 2 		left = 0 	right = 0


// ①
( 0, 0, 2, '', [] ) => 0 < 2 => ( 1, 0, 2, '(', [] )

// ②
( 1, 0, 2, '(', [] ) =>	1 < 2 => ( 2, 0, 2, '((', [] )
( 1, 0, 2, '(', [] ) => 0 < 1 => ( 1, 1, 2, '()', [])

// ③
( 2, 0, 2, '((', [] ) => 2 < 2 => !
( 2, 0, 2, '((', [] ) => 0 < 2 => (2, 1, 2, '(()', [])
( 1, 1, 2, '()', []) => 1 < 2 => (2, 1, 2, '()(', [])
( 1, 1, 2, '()', []) => 1 < 1 => !

// ④
(2, 1, 2, '(()', []) => 1 < 2 => (2, 2, 2, '(())', [])
(2, 1, 2, '()(', []) => 1 < 2 => (2, 2, 2, '()()', [])

[ '(())', '()()']

*/


/*

s = '' 		n = 3		left = 0		right = 0

// ①
( 0, 0, 3, '', [] ) => 0 < 3 => ( 1, 0, 3, '(', [] )
( 0, 0, 3, '', [] ) => 0 < 0 => !

// ②
( 1, 0, 3, '(', [] ) => 1 < 3 => ( 2, 0, 3, '((', [] )
( 1, 0, 3, '(', [] ) => 0 < 1 => ( 1, 1, 3, '()', [] )

// ③
( 2, 0, 3, '((', []) => 2 < 3 => ( 3, 0, 3, '(((', [] )
( 2, 0, 3, '((', []) => 0 < 2 => ( 2, 1, 3, '(()', [] )
( 1, 1, 3, '()', [] ) => 1 < 3 => ( 2, 1, 3, '()(', [] )
( 1, 1, 3, '()', [] ) => 1 < 1 => !

// ④
( 3, 0, 3, '(((', [] ) => 3 < 3 => !
( 3, 0, 3, '(((', [] ) => 0 < 3 => ( 3, 1, 3, '((()', [] )
( 2, 1, 3, '(()', [] ) => 2 < 3 => ( 3, 1, 3, '(()(', [] )
( 2, 1, 3, '(()', [] ) => 1 < 2 => ( 2, 2, 3, '(())', [] )
( 2, 1, 3, '()(', [] ) => 2 < 3 => ( 3, 1, 3, '()((', [] )
( 2, 1, 3, '()(', [] ) => 1 < 2 => ( 2, 2, 3, '()()', [] )

// ⑤
( 3, 1, 3, '((()', [] ) => 3 < 3 => ! 
( 3, 1, 3, '((()', [] ) => 1 < 3 => ( 3, 2, 3, '((())', [] )
( 3, 1, 3, '(()(', [] ) => 3 < 3 => !
( 3, 1, 3, '(()(', [] ) => 1 < 3 => ( 3, 2, 3, '(()()', [] )
// ...

*/